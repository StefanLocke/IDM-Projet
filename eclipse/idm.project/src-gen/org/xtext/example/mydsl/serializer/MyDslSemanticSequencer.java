/*
 * generated by Xtext 2.25.0
 */
package org.xtext.example.mydsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mydsl.idmdsl.Binexpr;
import org.xtext.example.mydsl.idmdsl.Colprod;
import org.xtext.example.mydsl.idmdsl.Colsum;
import org.xtext.example.mydsl.idmdsl.Create;
import org.xtext.example.mydsl.idmdsl.ExportCSV;
import org.xtext.example.mydsl.idmdsl.ExportJSON;
import org.xtext.example.mydsl.idmdsl.IdmdslPackage;
import org.xtext.example.mydsl.idmdsl.Insert;
import org.xtext.example.mydsl.idmdsl.InsertCol;
import org.xtext.example.mydsl.idmdsl.InsertLine;
import org.xtext.example.mydsl.idmdsl.IntValue;
import org.xtext.example.mydsl.idmdsl.Lineprod;
import org.xtext.example.mydsl.idmdsl.Linesum;
import org.xtext.example.mydsl.idmdsl.Load;
import org.xtext.example.mydsl.idmdsl.NoneValue;
import org.xtext.example.mydsl.idmdsl.Print;
import org.xtext.example.mydsl.idmdsl.Programme;
import org.xtext.example.mydsl.idmdsl.RemoveCol;
import org.xtext.example.mydsl.idmdsl.RemoveLine;
import org.xtext.example.mydsl.idmdsl.Selectcell;
import org.xtext.example.mydsl.idmdsl.StringValue;
import org.xtext.example.mydsl.services.MyDslGrammarAccess;

@SuppressWarnings("all")
public class MyDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MyDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == IdmdslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case IdmdslPackage.BINEXPR:
				sequence_Binexpr(context, (Binexpr) semanticObject); 
				return; 
			case IdmdslPackage.COLPROD:
				sequence_Colprod(context, (Colprod) semanticObject); 
				return; 
			case IdmdslPackage.COLSUM:
				sequence_Colsum(context, (Colsum) semanticObject); 
				return; 
			case IdmdslPackage.CREATE:
				sequence_Create(context, (Create) semanticObject); 
				return; 
			case IdmdslPackage.EXPORT_CSV:
				sequence_ExportCSV(context, (ExportCSV) semanticObject); 
				return; 
			case IdmdslPackage.EXPORT_JSON:
				sequence_ExportJSON(context, (ExportJSON) semanticObject); 
				return; 
			case IdmdslPackage.INSERT:
				sequence_Insert(context, (Insert) semanticObject); 
				return; 
			case IdmdslPackage.INSERT_COL:
				sequence_InsertCol(context, (InsertCol) semanticObject); 
				return; 
			case IdmdslPackage.INSERT_LINE:
				sequence_InsertLine(context, (InsertLine) semanticObject); 
				return; 
			case IdmdslPackage.INT_VALUE:
				sequence_IntValue(context, (IntValue) semanticObject); 
				return; 
			case IdmdslPackage.LINEPROD:
				sequence_Lineprod(context, (Lineprod) semanticObject); 
				return; 
			case IdmdslPackage.LINESUM:
				sequence_Linesum(context, (Linesum) semanticObject); 
				return; 
			case IdmdslPackage.LOAD:
				sequence_Load(context, (Load) semanticObject); 
				return; 
			case IdmdslPackage.NONE_VALUE:
				sequence_NoneValue(context, (NoneValue) semanticObject); 
				return; 
			case IdmdslPackage.PRINT:
				sequence_Print(context, (Print) semanticObject); 
				return; 
			case IdmdslPackage.PROGRAMME:
				sequence_Programme(context, (Programme) semanticObject); 
				return; 
			case IdmdslPackage.REMOVE_COL:
				sequence_RemoveCol(context, (RemoveCol) semanticObject); 
				return; 
			case IdmdslPackage.REMOVE_LINE:
				sequence_RemoveLine(context, (RemoveLine) semanticObject); 
				return; 
			case IdmdslPackage.SELECTCELL:
				sequence_Selectcell(context, (Selectcell) semanticObject); 
				return; 
			case IdmdslPackage.STRING_VALUE:
				sequence_StringValue(context, (StringValue) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Expression returns Binexpr
	 *     Binexpr returns Binexpr
	 *
	 * Constraint:
	 *     (left=PrimaryExpression op=Op right=Expression)
	 */
	protected void sequence_Binexpr(ISerializationContext context, Binexpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IdmdslPackage.Literals.BINEXPR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IdmdslPackage.Literals.BINEXPR__LEFT));
			if (transientValues.isValueTransient(semanticObject, IdmdslPackage.Literals.BINEXPR__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IdmdslPackage.Literals.BINEXPR__OP));
			if (transientValues.isValueTransient(semanticObject, IdmdslPackage.Literals.BINEXPR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IdmdslPackage.Literals.BINEXPR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBinexprAccess().getLeftPrimaryExpressionParserRuleCall_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getBinexprAccess().getOpOpParserRuleCall_2_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getBinexprAccess().getRightExpressionParserRuleCall_3_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Colprod
	 *     PrimaryExpression returns Colprod
	 *     Colprod returns Colprod
	 *
	 * Constraint:
	 *     (colIndex=Expression | name=STRING)
	 */
	protected void sequence_Colprod(ISerializationContext context, Colprod semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Colsum
	 *     PrimaryExpression returns Colsum
	 *     Colsum returns Colsum
	 *
	 * Constraint:
	 *     (colIndex=Expression | name=STRING)
	 */
	protected void sequence_Colsum(ISerializationContext context, Colsum semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Loadscope returns Create
	 *     Create returns Create
	 *
	 * Constraint:
	 *     instructions+=Instruction+
	 */
	protected void sequence_Create(ISerializationContext context, Create semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns ExportCSV
	 *     ExportCSV returns ExportCSV
	 *
	 * Constraint:
	 *     path=STRING
	 */
	protected void sequence_ExportCSV(ISerializationContext context, ExportCSV semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IdmdslPackage.Literals.EXPORT_CSV__PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IdmdslPackage.Literals.EXPORT_CSV__PATH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExportCSVAccess().getPathSTRINGTerminalRuleCall_1_0(), semanticObject.getPath());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns ExportJSON
	 *     ExportJSON returns ExportJSON
	 *
	 * Constraint:
	 *     path=STRING
	 */
	protected void sequence_ExportJSON(ISerializationContext context, ExportJSON semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IdmdslPackage.Literals.EXPORT_JSON__PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IdmdslPackage.Literals.EXPORT_JSON__PATH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExportJSONAccess().getPathSTRINGTerminalRuleCall_1_0(), semanticObject.getPath());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns InsertCol
	 *     InsertCol returns InsertCol
	 *
	 * Constraint:
	 *     (colIndex=Expression colName=STRING exp=Expression?)
	 */
	protected void sequence_InsertCol(ISerializationContext context, InsertCol semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns InsertLine
	 *     InsertLine returns InsertLine
	 *
	 * Constraint:
	 *     (lineIndex=Expression exps+=Expression+)
	 */
	protected void sequence_InsertLine(ISerializationContext context, InsertLine semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns Insert
	 *     Insert returns Insert
	 *
	 * Constraint:
	 *     (lineIndex=Expression colNameOrIndex=Expression (value=Expression | value=StringValue))
	 */
	protected void sequence_Insert(ISerializationContext context, Insert semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns IntValue
	 *     PrimaryExpression returns IntValue
	 *     IntValue returns IntValue
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_IntValue(ISerializationContext context, IntValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IdmdslPackage.Literals.INT_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IdmdslPackage.Literals.INT_VALUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntValueAccess().getValueINTTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Lineprod
	 *     PrimaryExpression returns Lineprod
	 *     Lineprod returns Lineprod
	 *
	 * Constraint:
	 *     lineIndex=Expression
	 */
	protected void sequence_Lineprod(ISerializationContext context, Lineprod semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IdmdslPackage.Literals.LINEPROD__LINE_INDEX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IdmdslPackage.Literals.LINEPROD__LINE_INDEX));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLineprodAccess().getLineIndexExpressionParserRuleCall_1_0(), semanticObject.getLineIndex());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Linesum
	 *     PrimaryExpression returns Linesum
	 *     Linesum returns Linesum
	 *
	 * Constraint:
	 *     lineIndex=Expression
	 */
	protected void sequence_Linesum(ISerializationContext context, Linesum semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IdmdslPackage.Literals.LINESUM__LINE_INDEX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IdmdslPackage.Literals.LINESUM__LINE_INDEX));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLinesumAccess().getLineIndexExpressionParserRuleCall_1_0(), semanticObject.getLineIndex());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Loadscope returns Load
	 *     Load returns Load
	 *
	 * Constraint:
	 *     (path=STRING instructions+=Instruction*)
	 */
	protected void sequence_Load(ISerializationContext context, Load semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns NoneValue
	 *     NoneValue returns NoneValue
	 *
	 * Constraint:
	 *     value='None'
	 */
	protected void sequence_NoneValue(ISerializationContext context, NoneValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IdmdslPackage.Literals.NONE_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IdmdslPackage.Literals.NONE_VALUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNoneValueAccess().getValueNoneKeyword_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns Print
	 *     Print returns Print
	 *
	 * Constraint:
	 *     (value=Expression | value=StringValue)
	 */
	protected void sequence_Print(ISerializationContext context, Print semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Programme returns Programme
	 *
	 * Constraint:
	 *     loadscopes+=Loadscope+
	 */
	protected void sequence_Programme(ISerializationContext context, Programme semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns RemoveCol
	 *     RemoveCol returns RemoveCol
	 *
	 * Constraint:
	 *     (colIndex=Expression | name=STRING)
	 */
	protected void sequence_RemoveCol(ISerializationContext context, RemoveCol semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns RemoveLine
	 *     RemoveLine returns RemoveLine
	 *
	 * Constraint:
	 *     lineIndex=Expression
	 */
	protected void sequence_RemoveLine(ISerializationContext context, RemoveLine semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IdmdslPackage.Literals.REMOVE_LINE__LINE_INDEX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IdmdslPackage.Literals.REMOVE_LINE__LINE_INDEX));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRemoveLineAccess().getLineIndexExpressionParserRuleCall_1_0(), semanticObject.getLineIndex());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Selectcell
	 *     PrimaryExpression returns Selectcell
	 *     Selectcell returns Selectcell
	 *
	 * Constraint:
	 *     (cellX=Expression cellY=Expression)
	 */
	protected void sequence_Selectcell(ISerializationContext context, Selectcell semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IdmdslPackage.Literals.SELECTCELL__CELL_X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IdmdslPackage.Literals.SELECTCELL__CELL_X));
			if (transientValues.isValueTransient(semanticObject, IdmdslPackage.Literals.SELECTCELL__CELL_Y) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IdmdslPackage.Literals.SELECTCELL__CELL_Y));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSelectcellAccess().getCellXExpressionParserRuleCall_1_0(), semanticObject.getCellX());
		feeder.accept(grammarAccess.getSelectcellAccess().getCellYExpressionParserRuleCall_3_0(), semanticObject.getCellY());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StringValue returns StringValue
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_StringValue(ISerializationContext context, StringValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, IdmdslPackage.Literals.STRING_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, IdmdslPackage.Literals.STRING_VALUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringValueAccess().getValueSTRINGTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
}
